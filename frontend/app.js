// ------- App State -------
const state = {
  loaded: false,
  // mode: "monte",
  floors: 4,
  startFloor: 0,
  scale: 0.33167,
  images: {}, // { floorIndex: ObjectURL }
  currentFloor: 0,
  imageLocked: true,

  graph: { nodes: [], links: [] },
  view: { scale: 1, tx: 0, ty: 0 },
  tool: "select",
  selection: { type: null, id: null },

  snap: {
    active: true,
    tol: 8, // Ïä§ÎÉÖ ÌóàÏö© ÌîΩÏÖÄ
    candidate: null, // { orient:'v'|'h', x?, y? }
  },
};
state.keys = { shift: false };
state.mouse = { x: 0, y: 0 };
state.snapGuide = null;
state.longPress = { active: false, timer: null, threshold: 220, anchor: null };
state.longPressMoveCancel = 6;
state.snap = state.snap ?? {
  active: true,
  tol: 10, // Ïä§ÎÉÖ ÌóàÏö© ÌîΩÏÖÄ
  cand: { v: null, h: null }, // { v:{x,ax,ay,dx}, h:{y,ax,ay,dy} }
};

// ------- Elements -------
const els = {
  btnNew: document.getElementById("btnNew"),
  btnOpen: document.getElementById("btnOpen"),
  btnSave: document.getElementById("btnSave"),
  floorSelect: document.getElementById("floorSelect"),
  btnLoadBg: document.getElementById("btnLoadBg"),
  btnClearBg: document.getElementById("btnClearBg"),
  btnLock: document.getElementById("btnLock"),
  bgName: document.getElementById("bgName"),
  canvas: document.getElementById("canvas"),
  stage: document.getElementById("stage"),
  bgImg: document.getElementById("bgImg"),
  empty: document.getElementById("emptyState"),
  status: document.getElementById("status"),
  projName: document.getElementById("projName"),
  projState: document.getElementById("projState"),
  floorLbl: document.getElementById("floorLbl"),
  selLbl: document.getElementById("selLbl"),
  layerInfo: document.getElementById("layerInfo"),
  totalInfo: document.getElementById("totalInfo"),

  // modal
  modalBack: document.getElementById("newModalBack"),
  closeModal: document.getElementById("closeModal"),
  floorCount: document.getElementById("floorCount"),
  startFloor: document.getElementById("startFloor"),
  scale: document.getElementById("scale"),
  floorFiles: document.getElementById("floorFiles"),
  modalOk: document.getElementById("btnModalOk"),
  modalReset: document.getElementById("btnModalReset"),
  startX: document.getElementById("startX"),
  startY: document.getElementById("startY"),
  btnPickStart: document.getElementById("btnPickStart"),
  overlay: document.getElementById("overlay"),

  // node props
  nodeGroup: document.getElementById("nodeGroup"),
  nodeId: document.getElementById("nodeId"),
  nodeName: document.getElementById("nodeName"),
  nodeX: document.getElementById("nodeX"),
  nodeY: document.getElementById("nodeY"),

  // link props
  linkGroup: document.getElementById("linkGroup"),
  linkId: document.getElementById("linkId"),
  linkFrom: document.getElementById("linkFrom"),
  linkTo: document.getElementById("linkTo"),
  linkType: document.getElementById("linkType"),
};

// ---------------------------------------
// ------------- Helpers -----------------
function setEnabled(enabled) {
  document.querySelectorAll(".toolbtn").forEach((b) => (b.disabled = !enabled));
  [
    els.floorSelect,
    els.btnLoadBg,
    els.btnClearBg,
    els.btnLock,
    els.startX,
    els.startY,
    els.btnPickStart,
  ].forEach((e) => (e.disabled = !enabled));
  els.btnSave.disabled = !enabled;
}
function openModal() {
  els.modalBack.style.display = "flex";
  // seed selects
  buildStartFloorOptions(parseInt(els.floorCount.value || "1", 10));
  buildFloorFileRows();
}
function closeModal() {
  els.modalBack.style.display = "none";
}
function buildStartFloorOptions(n) {
  els.startFloor.innerHTML = "";
  for (let i = 0; i < n; i++) {
    const o = document.createElement("option");
    o.value = i;
    o.textContent = i + 1 + "Ï∏µ";
    els.startFloor.appendChild(o);
  }
}
function buildFloorFileRows() {
  const n = parseInt(els.floorCount.value || "1", 10);
  els.floorFiles.innerHTML = "";
  for (let i = 0; i < n; i++) {
    const row = document.createElement("div");
    row.className = "floor-grid";
    const label = document.createElement("div");
    label.textContent = i + 1 + "Ï∏µ";
    const name = document.createElement("div");
    name.id = "fileName_" + i;
    name.className = "pill";
    name.textContent = "Ïù¥ÎØ∏ÏßÄ ÏóÜÏùå";
    const sel = document.createElement("button");
    sel.className = "btn";
    sel.textContent = "ÏÑ†ÌÉù";
    const rem = document.createElement("button");
    rem.className = "btn";
    rem.textContent = "Ï†úÍ±∞";
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";
    input.className = "hidden";
    sel.onclick = () => {
      input.click();
    };
    input.onchange = () => {
      if (input.files[0]) {
        const url = URL.createObjectURL(input.files[0]);
        state.images[i] = url;
        name.textContent = input.files[0].name;
        if (state.loaded && state.currentFloor === i) renderFloor();
      }
    };
    rem.onclick = () => {
      if (state.images[i]) {
        URL.revokeObjectURL(state.images[i]);
        delete state.images[i];
        name.textContent = "Ïù¥ÎØ∏ÏßÄ ÏóÜÏùå";
        if (state.loaded && state.currentFloor === i) renderFloor();
      }
    };
    row.append(label, name, sel, rem, input);
    els.floorFiles.appendChild(row);
  }
}
function renderFloor() {
  const url = state.images[state.currentFloor];
  if (url) {
    els.bgImg.src = url;
    els.bgImg.style.display = "block";
    els.bgName.textContent =
      els.floorFiles.querySelector("#fileName_" + state.currentFloor)
        ?.textContent || "Ïù¥ÎØ∏ÏßÄ";
  } else {
    els.bgImg.removeAttribute("src");
    els.bgImg.style.display = "none";
    els.bgName.textContent = "Ïù¥ÎØ∏ÏßÄ ÏóÜÏùå";
  }
  els.floorLbl.textContent = "üè¢ Ï∏µ: " + (state.currentFloor + 1);

  // redrawOverlay();
}
els.bgImg.addEventListener("load", () => {
  const natW = els.bgImg.naturalWidth || 1;
  const natH = els.bgImg.naturalHeight || 1;
  // stage/overlayÎ•º ÏûêÏó∞ Ìï¥ÏÉÅÎèÑ Í∏∞Ï§ÄÏúºÎ°ú ÎßûÏ∂îÍ∏∞
  els.stage.style.width = `${natW}px`;
  els.stage.style.height = `${natH}px`;
  // Ï¥àÍ∏∞ÎèÑ ÏÇ¥Ïßù Í∞ÄÏö¥Îç∞ Î≥¥Ïù¥Í≤å ÌïòÎ†§Î©¥ tx/ty Ï°∞Ï†ï Í∞ÄÎä•(ÏòµÏÖò)
  applyViewTransform();
  redrawOverlay();
});

function populateFloorSelect() {
  els.floorSelect.innerHTML = "";
  for (let i = 0; i < state.floors; i++) {
    const o = document.createElement("option");
    o.value = i;
    o.textContent = i + 1 + "Ï∏µ";
    els.floorSelect.appendChild(o);
  }
  els.floorSelect.value = String(state.currentFloor);
}
function activateProject() {
  state.loaded = true;
  setEnabled(true);
  els.empty.style.display = "none";
  els.status.textContent =
    "ÌîÑÎ°úÏ†ùÌä∏Í∞Ä Î°úÎìúÎêòÏóàÏäµÎãàÎã§. ÏûëÏóÖÏùÑ ÏãúÏûëÌï† Ïàò ÏûàÏäµÎãàÎã§.";
  populateFloorSelect();
  renderFloor();
}

// ------------------------------------------------------------
// -------------------- snap ----------------------------------
function collectSnapAnchors() {
  const a = [];
  // 1) ÎÖ∏Îìú
  for (const n of state.graph.nodes) a.push({ x: n.x, y: n.y });

  // 2) (ÏÑ†ÌÉù) ÎßÅÌÅ¨ ÎÅùÏ†ê
  for (const l of state.graph.links || []) {
    const A = state.graph.nodes.find((n) => n.id === l.a);
    const B = state.graph.nodes.find((n) => n.id === l.b);
    if (A) a.push({ x: A.x, y: A.y });
    if (B) a.push({ x: B.x, y: B.y });
  }

  // 3) (ÏûàÎã§Î©¥) ÏÇ¨Í∞ÅÌòï/Ìè¥Î¶¨Í≥§ Íº≠ÏßìÏ†ê
  for (const r of state.graph.rects || []) {
    a.push({ x: r.x, y: r.y });
    a.push({ x: r.x + r.w, y: r.y });
    a.push({ x: r.x, y: r.y + r.h });
    a.push({ x: r.x + r.w, y: r.y + r.h });
  }
  for (const p of state.graph.polys || []) {
    for (const [x, y] of p.points) a.push({ x, y });
  }
  return a;
}

function getAxisSnapCandidates(px, py, tol = state.snap.tol) {
  const anchors = collectSnapAnchors();
  let v = null; // { x, ax, ay, dx }
  let h = null; // { y, ax, ay, dy }
  for (const p of anchors) {
    const dx = Math.abs(px - p.x);
    const dy = Math.abs(py - p.y);
    if (dx <= tol && (!v || dx < v.dx)) v = { x: p.x, ax: p.x, ay: p.y, dx };
    if (dy <= tol && (!h || dy < h.dy)) h = { y: p.y, ax: p.x, ay: p.y, dy };
  }
  return { v, h };
}

function drawSnapGuides(svg) {
  // Í∏∞Ï°¥ Í∞ÄÏù¥Îìú Ï†úÍ±∞
  const old = svg.querySelector("#snap-guides");
  if (old) old.remove();

  const { v, h } = state.snap.cand || {};
  if (!v && !h) return;

  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  g.setAttribute("id", "snap-guides");
  g.setAttribute("pointer-events", "none");

  const W =
    state.imageSize?.width ?? svg.viewBox.baseVal.width ?? svg.clientWidth;
  const H =
    state.imageSize?.height ?? svg.viewBox.baseVal.height ?? svg.clientHeight;

  // Ïä§ÌÉÄÏùº Í≥µÌÜµ
  const mkLine = () => {
    const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
    ln.setAttribute("stroke", "#FF3B30"); // Î≥¥Í∏∞ Ïâ¨Ïö¥ Îπ®Í∞ï
    ln.setAttribute("stroke-width", "1.5");
    ln.setAttribute("stroke-dasharray", "6 6");
    ln.setAttribute("pointer-events", "none");
    return ln;
  };

  if (v) {
    const ln = mkLine();
    ln.setAttribute("x1", v.x);
    ln.setAttribute("y1", 0);
    ln.setAttribute("x2", v.x);
    ln.setAttribute("y2", H);
    g.appendChild(ln);
    // const dot = document.createElementNS(
    //   "http://www.w3.org/2000/svg",
    //   "circle"
    // );
    // dot.setAttribute("cx", v.ax);
    // dot.setAttribute("cy", v.ay);
    // dot.setAttribute("r", 3);
    // dot.setAttribute("fill", "#FF3B30");
    // g.appendChild(dot);
  }
  if (h) {
    const ln = mkLine();
    ln.setAttribute("x1", 0);
    ln.setAttribute("y1", h.y);
    ln.setAttribute("x2", W);
    ln.setAttribute("y2", h.y);
    g.appendChild(ln);
    // const dot = document.createElementNS(
    //   "http://www.w3.org/2000/svg",
    //   "circle"
    // );
    // dot.setAttribute("cx", h.ax);
    // dot.setAttribute("cy", h.ay);
    // dot.setAttribute("r", 3);
    // dot.setAttribute("fill", "#FF3B30");
    // g.appendChild(dot);
  }

  const mkDot = (cx, cy) => {
    const dot = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    dot.setAttribute("cx", h.ax);
    dot.setAttribute("cy", h.ay);
    dot.setAttribute("r", 3);
    dot.setAttribute("fill", "#FF3B30");
    dot.setAttribute("pointer-events", "none");
    return dot;
  };

  if (v && h) {
    g.appendChild(mkDot(v.x, h.y));
  } else if (v) {
    const cy = v.ay != null ? v.ay : state.mouse?.y ?? 0;
    g.appendChild(mkDot(v.x, cy));
  } else if (h) {
    const cx = h.ax != null ? h.ax : state.mouse?.x ?? 0;
    g.appendChild(mkDot(cx, h.y));
  }

  svg.appendChild(g);
}

window.addEventListener(
  "wheel",
  (e) => {
    if (e.ctrlKey) e.preventDefault();
  },
  { passive: false }
);
window.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && ["=", "+", "-", "_"].includes(e.key)) {
    e.preventDefault();
  }
});
// Ìú†Î°ú ÌôïÎåÄ/Ï∂ïÏÜå (Ctrl Î∂àÌïÑÏöî) ‚Äì ÎßàÏö∞Ïä§ Í∏∞Ï§Ä Ï§å
els.canvas.addEventListener(
  "wheel",
  (e) => {
    // Ïä§ÌÅ¨Î°§ ÌéòÏù¥ÏßÄ Ïù¥Îèô Î∞©ÏßÄ
    e.preventDefault();
    const { left, top } = els.canvas.getBoundingClientRect();
    const mx = e.clientX - left; // Ï∫îÎ≤ÑÏä§ Ï¢åÌëú
    const my = e.clientY - top;

    const prev = { ...state.view };
    const factor = e.deltaY < 0 ? 1.12 : 1 / 1.12; // Ï§å Ïä§ÌÖù
    const minScale = 0.2,
      maxScale = 8;
    const nextScale = Math.min(
      maxScale,
      Math.max(minScale, prev.scale * factor)
    );

    // ÌôîÎ©¥ÏÉÅ (mx,my)Ïóê ÏûàÎäî Ïù¥ÎØ∏ÏßÄ Ï¢åÌëú(ÏûêÏó∞ Ìï¥ÏÉÅÎèÑ Í∏∞Ï§Ä) Íµ¨ÌïòÍ∏∞
    const imgX = (mx - prev.tx) / prev.scale;
    const imgY = (my - prev.ty) / prev.scale;

    // Í∞ôÏùÄ Ïù¥ÎØ∏ÏßÄ Ï†êÏù¥ Ï§å ÌõÑÏóêÎèÑ Í∞ôÏùÄ ÌôîÎ©¥ ÏúÑÏπòÏóê Ïò§ÎèÑÎ°ù tx,ty Î≥¥Ï†ï
    state.view.scale = nextScale;
    state.view.tx = mx - imgX * nextScale;
    state.view.ty = my - imgY * nextScale;

    applyViewTransform();
  },
  { passive: false }
);
let isPanning = false;
let panStart = { x: 0, y: 0 };
let viewStart = { tx: 0, ty: 0 };

els.canvas.addEventListener("mousedown", (e) => {
  // Ïä§ÌéòÏù¥Ïä§Î∞îÎ•º ÎàÑÎ•¥Í≥† ÎìúÎûòÍ∑∏ÌïòÎ©¥ ÌôîÎ©¥ Ïù¥Îèô
  if (
    !e.button &&
    e.shiftKey === false &&
    e.altKey === false &&
    e.ctrlKey === false &&
    e.metaKey === false
  ) {
    // Í∏∞Î≥∏ÏùÄ Ìà¥ ÌÅ¥Î¶≠ ÎèôÏûëÏù¥ ÏûàÏúºÎãà, 'Ïä§ÌéòÏù¥Ïä§'Î°úÎßå Ìå¨ÌïòÍ≥† Ïã∂ÏúºÎ©¥ ÏïÑÎûò Ï°∞Í±¥ÏùÑ Î∞îÍøî:
    // if (!e.button && e.code === 'Space') ...
  }
  if (
    e.button === 1 ||
    e.code === "Space" ||
    e.buttons === 4 ||
    e.which === 2
  ) {
    e.preventDefault();
  }
});

// Í∂åÏû•: Ïä§ÌéòÏù¥Ïä§ ÎàÑÎ•¥Î©¥ Ìå¨Î™®Îìú
let spaceHeld = false;
let draggingNodeId = null;
let dragStart = null;
let nodeStart = null;
window.addEventListener("keydown", (e) => {
  if (e.code === "Space") spaceHeld = true;
  if (e.key === "Shift") state.keys.shift = true;
});
window.addEventListener("keyup", (e) => {
  if (e.code === "Space") spaceHeld = false;
  if (e.key === "Shift") {
    state.keys.shift = false;
    state.snapGuide = null;
    redrawOverlay();
  }
});

els.canvas.addEventListener("pointerdown", (e) => {
  if (spaceHeld || e.button === 1) {
    // Ïä§ÌéòÏù¥Ïä§ or Ìú†Î≤ÑÌäº
    e.preventDefault();
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY };
    viewStart = { tx: state.view.tx, ty: state.view.ty };
    els.canvas.setPointerCapture(e.pointerId);
  }
});
els.canvas.addEventListener("pointermove", (e) => {
  if (!isPanning) return;
  const dx = e.clientX - panStart.x;
  const dy = e.clientY - panStart.y;
  state.view.tx = viewStart.tx + dx;
  state.view.ty = viewStart.ty + dy;
  applyViewTransform();
});
els.canvas.addEventListener("pointerup", (e) => {
  if (isPanning) {
    isPanning = false;
    els.canvas.releasePointerCapture(e.pointerId);
  }
});
function imagePointFromClient(ev) {
  const { left, top } = els.canvas.getBoundingClientRect();
  // const { scale, tx, ty } = state.view;
  const view = state.view || { scale: 1, tx: 0, ty: 0 };
  const cx = ev.clientX - left;
  const cy = ev.clientY - top;
  const x = (cx - view.tx) / view.scale;
  const y = (cy - view.ty) / view.scale;
  const natW = els.bgImg.naturalWidth || els.bgImg.width || 0;
  const natH = els.bgImg.naturalHeight || els.bgImg.height || 0;

  return {
    x,
    y,
    rect: { left: 0, top: 0, width: natW, height: natH },
  };
}

function snapToAxisOfExisting(px, py, tol = 8) {
  let outX = px,
    outY = py,
    best = Infinity;
  for (const n of state.graph.nodes) {
    const dx = Math.abs(px - n.x);
    const dy = Math.abs(py - n.y);
    if (dx <= tol && dx < best) {
      outX = n.x;
      best = dx;
    }
    if (dy <= tol && dy < best) {
      outY = n.y;
      best = dy;
    }
  }
  return { x: outX, y: outY };
}

function redrawOverlay() {
  const svg = els.overlay;
  const natW = els.bgImg.naturalWidth || els.bgImg.width || 1;
  const natH = els.bgImg.naturalHeight || els.bgImg.height || 1;

  // ‚úÖ ÎÇ¥Î∂Ä Ï¢åÌëúÍ≥ÑÎ•º 'ÏûêÏó∞ Ìï¥ÏÉÅÎèÑ'Î°ú Í≥†Ï†ï
  // svg.style.left = `0px`;
  // svg.style.top = `0px`;
  svg.style.width = `${natW}px`;
  svg.style.height = `${natH}px`;
  svg.setAttribute("viewBox", `0 0 ${natW} ${natH}`);
  svg.setAttribute("width", natW);
  svg.setAttribute("height", natH);

  while (svg.firstChild) svg.removeChild(svg.firstChild);

  // links
  for (const lk of state.graph.links) {
    const a = state.graph.nodes.find((n) => n.id === lk.a);
    const b = state.graph.nodes.find((n) => n.id === lk.b);
    if (!a || !b) continue;

    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const hit = document.createElementNS("http://www.w3.org/2000/svg", "line");

    hit.classList.add("link-hit");
    hit.setAttribute("x1", a.x);
    hit.setAttribute("y1", a.y);
    hit.setAttribute("x2", b.x);
    hit.setAttribute("y2", b.y);
    hit.setAttribute("pointer-events", "stroke");
    hit.setAttribute("stroke", "transparent");
    hit.setAttribute("stroke-width", "14"); // ÎÑâÎÑâÌïú ÌûàÌä∏Î∞ïÏä§
    hit.dataset.id = lk.id;
    hit.addEventListener(
      "pointerdown",
      (e) => {
        if (state.tool !== "select") return;
        e.stopPropagation();
        e.preventDefault();
        selectLink(lk.id);
      },
      { passive: false }
    );

    // ‚ë° Ïã§Ï†ú Î≥¥Ïù¥Îäî ÎùºÏù∏
    const vis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    vis.classList.add("link-line");
    vis.setAttribute("x1", a.x);
    vis.setAttribute("y1", a.y);
    vis.setAttribute("x2", b.x);
    vis.setAttribute("y2", b.y);
    vis.dataset.id = lk.id;
    if (state.selection?.type === "link" && state.selection.id === lk.id) {
      vis.classList.add("selected");
    }

    g.appendChild(hit);
    g.appendChild(vis);
    svg.appendChild(g);
    // const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    // line.setAttribute("x1", a.x);
    // line.setAttribute("y1", a.y);
    // line.setAttribute("x2", b.x);
    // line.setAttribute("y2", b.y);
    // line.classList.add("link-line");
    // line.setAttribute("pointer-events", "stroke");
    // line.setAttribute("stroke-width", "6");
    // if (state.selection.type === "link" && state.selection.id === lk.id) {
    //   line.classList.add("selected");
    // }
    // line.dataset.id = lk.id;
    // line.addEventListener("click", (e) => {
    //   if (state.tool === "select") {
    //     e.stopPropagation();
    //     selectLink(lk.id);
    //   }
    // });
    // svg.appendChild(line);
  }

  // nodes
  for (const n of state.graph.nodes) {
    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    c.setAttribute("cx", n.x);
    c.setAttribute("cy", n.y);
    c.setAttribute("r", 5);
    c.classList.add("node-dot");
    if (state.selection.type === "node" && state.selection.id === n.id) {
      c.classList.add("selected");
    }

    if (state.tool === "link" && pendingLinkFrom === n.id) {
      c.classList.add("selected-node");
    }

    c.dataset.id = n.id;
    c.addEventListener("click", (e) => {
      if (state.tool === "select") {
        e.stopPropagation();
        selectNode(n.id);
      } else if (state.tool === "link") {
        e.stopPropagation();
        handleLinkPick(n.id);
      }
    });
    c.addEventListener("pointerdown", (e) => {
      if (state.tool !== "select") return;
      e.stopPropagation();
      e.preventDefault();
      selectNode(n.id);
      const { x, y } = imagePointFromClient(e);
      draggingNodeId = n.id;
      dragStart = { x, y };
      nodeStart = { x: n.x, y: n.y };
      els.overlay.setPointerCapture(e.pointerId);
    });
    svg.appendChild(c);
  }

  if (state.tool === "link" && pendingLinkFrom) {
    const startNode = state.graph.nodes.find((n) => n.id === pendingLinkFrom);
    if (startNode) {
      let px = state.mouse.x;
      let py = state.mouse.y;
      let orient = null;

      if (state.keys.shift) {
        const dx = Math.abs(px - startNode.x);
        const dy = Math.abs(py - startNode.y);
        orient = dx >= dy ? "h" : "v";
        if (orient === "h") py = startNode.y;
        else px = startNode.x;
        // Í∞ÄÏù¥Îìú ÏÑ∏ÌåÖ (redrawÍ∞Ä Ïó¨Îü¨ Î≤à Î∂àÎ†§ÎèÑ Î¨∏Ï†ú ÏóÜÏùå)
        state.snapGuide = {
          anchor: { x: startNode.x, y: startNode.y },
          orient,
        };
      } else {
        state.snapGuide = null;
      }

      const pl = document.createElementNS("http://www.w3.org/2000/svg", "line");
      pl.setAttribute("x1", startNode.x);
      pl.setAttribute("y1", startNode.y);
      pl.setAttribute("x2", px);
      pl.setAttribute("y2", py);
      pl.classList.add("preview-line");
      svg.appendChild(pl);
    }
  }

  drawSnapGuides(els.overlay);

  // ÌÜµÍ≥Ñ Í∞±Ïã†
  els.layerInfo.innerHTML = `üîµ ÎÖ∏Îìú: ${state.graph.nodes.length}<br/>üîó ÎßÅÌÅ¨: ${state.graph.links.length}`;
  els.totalInfo.innerHTML = els.layerInfo.innerHTML;
}

window.addEventListener("resize", redrawOverlay);

function applyViewTransform() {
  const { scale, tx, ty } = state.view;
  els.stage.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
}

function hasLinkBetween(a, b) {
  return state.graph.links.some(
    (l) => (l.a === a && l.b === b) || (l.a === b && l.b === a)
  );
}

let pendingLinkFrom = null;
function handleLinkPick(nodeId) {
  if (!pendingLinkFrom) {
    pendingLinkFrom = nodeId;
    els.status.textContent = `ÎßÅÌÅ¨ ÏãúÏûë ÎÖ∏Îìú ÏÑ†ÌÉùÎê®. Îã§Ïùå ÎÖ∏ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.`;
    redrawOverlay();
  } else {
    // 1) ÏûêÍ∏∞ ÏûêÏã† ÌÅ¥Î¶≠ Î∞©ÏßÄ
    if (pendingLinkFrom === nodeId) {
      els.status.textContent =
        "Í∞ôÏùÄ ÎÖ∏ÎìúÎ•º Îëê Î≤à ÏÑ†ÌÉùÌï† Ïàò ÏóÜÏäµÎãàÎã§. (ÏÑ†ÌÉù Ï∑®ÏÜå)";
      pendingLinkFrom = null;
      redrawOverlay();
      return;
    }

    // 2) Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÎßÅÌÅ¨ Î∞©ÏßÄ(Î¨¥Î∞©Ìñ• Ï§ëÎ≥µ Ï≤¥ÌÅ¨)
    if (hasLinkBetween(pendingLinkFrom, nodeId)) {
      els.status.textContent = "Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú ÎÖ∏Îìú ÏåçÏûÖÎãàÎã§.";
      // ÏõêÌïòÎ©¥ Í∏∞Ï°¥ ÎßÅÌÅ¨Î•º ÏÑ†ÌÉù ÏÉÅÌÉúÎ°ú
      const existing = state.graph.links.find(
        (l) =>
          (l.a === pendingLinkFrom && l.b === nodeId) ||
          (l.a === nodeId && l.b === pendingLinkFrom)
      );
      if (existing) selectLink(existing.id);
      pendingLinkFrom = null;
      redrawOverlay();
      return;
    }

    const newLink = {
      id: `lk_${Math.random().toString(36).slice(2, 8)}`,
      a: pendingLinkFrom,
      b: nodeId,
      type: "ÏùºÎ∞ò",
    };
    state.graph.links.push(newLink);
    pendingLinkFrom = null;
    selectLink(newLink.id);
    redrawOverlay();
  }
}

function selectNode(id) {
  state.selection = { type: "node", id };
  const n = state.graph.nodes.find((x) => x.id === id);
  els.selLbl.textContent = `üëÜ ÏÑ†ÌÉù: ÎÖ∏Îìú ${n?.name ? n.name : n.id}`;
  els.nodeGroup.style.display = "block";
  els.linkGroup.style.display = "none";
  els.nodeId.value = n.id;
  els.nodeName.value = n.name || "";
  els.nodeX.value = Math.round(n.x);
  els.nodeY.value = Math.round(n.y);
  redrawOverlay();
}

function selectLink(id) {
  state.selection = { type: "link", id };
  const l = state.graph.links.find((x) => x.id === id);
  els.selLbl.textContent = `üëÜ ÏÑ†ÌÉù: ÎßÅÌÅ¨ ${l?.id}`;
  els.nodeGroup.style.display = "none";
  els.linkGroup.style.display = "block";
  els.linkId.value = l.id;
  // ÎÖ∏Îìú Î™©Î°ù ÎìúÎ°≠Îã§Ïö¥ Ï±ÑÏö∞Í∏∞
  const opts = state.graph.nodes
    .map(
      (n) =>
        `<option value="${n.id}">${
          n.name ? n.name + " (" + n.id + ")" : n.id
        }</option>`
    )
    .join("");
  els.linkFrom.innerHTML = opts;
  els.linkTo.innerHTML = opts;
  els.linkFrom.value = l.a;
  els.linkTo.value = l.b;
  els.linkType.value = l.type || "ÏùºÎ∞ò";
  redrawOverlay();
}
function clearSelection() {
  state.selection = { type: null, id: null };
  els.selLbl.textContent = "üëÜ ÏÑ†ÌÉù: ÏóÜÏùå";
  els.nodeGroup.style.display = "none";
  els.linkGroup.style.display = "none";
  redrawOverlay();
}

// ------- Events -------
els.btnNew.addEventListener("click", openModal);
els.closeModal.addEventListener("click", closeModal);
els.floorCount.addEventListener("input", () => {
  buildStartFloorOptions(parseInt(els.floorCount.value || "1", 10));
  buildFloorFileRows();
});

els.modalReset.addEventListener("click", () => {
  // els.mode.value = "monte";
  els.floorCount.value = 4;
  els.scale.value = "0.33167";
  buildStartFloorOptions(4);
  els.startFloor.value = "0";
  buildFloorFileRows();
});

els.modalOk.addEventListener("click", () => {
  // read settings
  // state.mode = els.mode.value;
  state.floors = Math.max(
    1,
    Math.min(12, parseInt(els.floorCount.value || "1", 10))
  );
  state.startFloor = parseInt(els.startFloor.value || "0", 10);
  state.scale = parseFloat(els.scale.value || "0.33167");
  state.currentFloor = state.startFloor;
  els.projName.textContent = "Ïù¥Î¶Ñ: ÏÉà ÌîÑÎ°úÏ†ùÌä∏";
  els.projState.textContent = "ÏÉÅÌÉú: Ï†ÄÏû•Îê®";
  els.projState.style.color = "#27ae60";
  closeModal();
  activateProject();
  state.graph = { nodes: [], links: [] };
  clearSelection();
});

els.floorSelect.addEventListener("change", (e) => {
  state.currentFloor = parseInt(e.target.value, 10);
  renderFloor();
});

els.btnLoadBg.addEventListener("click", () => {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "image/*";
  input.onchange = () => {
    if (input.files[0]) {
      const url = URL.createObjectURL(input.files[0]);
      state.images[state.currentFloor] = url;
      renderFloor();
    }
  };
  input.click();
});

els.btnClearBg.addEventListener("click", () => {
  if (state.images[state.currentFloor]) {
    URL.revokeObjectURL(state.images[state.currentFloor]);
    delete state.images[state.currentFloor];
    renderFloor();
  }
});

els.btnLock.addEventListener("click", () => {
  state.imageLocked = !state.imageLocked;
  els.btnLock.textContent = state.imageLocked
    ? "üîí Ïù¥ÎØ∏ÏßÄ Í≥†Ï†ï"
    : "üîì Ïù¥ÎØ∏ÏßÄ Í≥†Ï†ï Ìï¥Ï†ú";
});

// ÏãúÏûëÏ†ê Ï∞çÍ∏∞ (V0: Ï¢åÌëúÎßå Í∏∞Î°ù)
els.btnPickStart.addEventListener("click", () => {
  if (!state.loaded) return;
  els.status.textContent = "ÏãúÏûëÏ†ê Ï∞çÍ∏∞ Î™®Îìú: Ïù¥ÎØ∏ÏßÄ ÏúÑÎ•º ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.";
  const once = (ev) => {
    if (ev.target.id !== "bgImg") {
      els.canvas.removeEventListener("click", once);
      els.status.textContent = "ÏãúÏûëÏ†ê ÏÑ†ÌÉùÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.";
      return;
    }
    const rect = els.bgImg.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    els.startX.value = x.toFixed(1);
    els.startY.value = y.toFixed(1);
    els.status.textContent = `ÏãúÏûëÏ†êÏù¥ ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§: (${x.toFixed(
      1
    )}, ${y.toFixed(1)})`;
    els.canvas.removeEventListener("click", once);
  };
  els.canvas.addEventListener("click", once);
});

// Ï¥àÍ∏∞ ÏÉÅÌÉú: Ìé∏Ïßë ÎπÑÌôúÏÑ±
setEnabled(false);
// Î™®Îã¨ Ï¥àÍ∏∞ ÏòµÏÖò
buildStartFloorOptions(4);
buildFloorFileRows();

// ÎßàÏö∞Ïä§ Ïù¥Îèô Ïãú ÌòÑÏû¨ Ï¢åÌëú Í∞±Ïã† (ÎßÅÌÅ¨ ÎØ∏Î¶¨Î≥¥Í∏∞/ÎìúÎûòÍ∑∏ÏóêÏÑú ÏÇ¨Ïö©)
els.overlay.addEventListener("pointermove", (ev) => {
  const pt = imagePointFromClient(ev);
  state.mouse = { x: pt.x, y: pt.y };

  // ÎÖ∏Îìú ÎèÑÍµ¨Ïùº Îïå Ïä§ÎÉÖ ÌõÑÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
  if (state.tool === "node" && state.snap.active) {
    state.snap.cand = getAxisSnapCandidates(pt.x, pt.y, state.snap.tol);
  } else {
    state.snap.cand = { v: null, h: null };
  }
  redrawOverlay();

  // ÎÖ∏Îìú ÎìúÎûòÍ∑∏ Ï§ëÏù¥Î©¥ Ï¢åÌëú ÏóÖÎç∞Ïù¥Ìä∏
  if (draggingNodeId) {
    const n = state.graph.nodes.find((nd) => nd.id === draggingNodeId);
    if (!n) return;

    // Ïù¥ÎèôÎüâ
    let dx = pt.x - dragStart.x;
    let dy = pt.y - dragStart.y;

    // Shift Ïä§ÎÉÖ: ÏàòÌèâ/ÏàòÏßÅÏúºÎ°úÎßå
    if (state.keys.shift) {
      // Ïñ¥Îñ§ Ï∂ïÏúºÎ°ú Í≥†Ï†ïÎêòÎäîÏßÄ Í≤∞Ï†ï
      const orient = Math.abs(dx) >= Math.abs(dy) ? "h" : "v";
      if (orient === "h") dy = 0;
      else dx = 0;

      // Í∞ÄÏù¥Îìú: Í∏∞Ï§ÄÏùÄ ÎìúÎûòÍ∑∏ ÏãúÏûë ÎãπÏãú ÎÖ∏Îìú Ï¢åÌëú(nodeStart)
      state.snapGuide = { anchor: { x: nodeStart.x, y: nodeStart.y }, orient };
    } else {
      state.snapGuide = null;
    }

    n.x = nodeStart.x + dx;
    n.y = nodeStart.y + dy;
    redrawOverlay();
  } else {
    // ÎìúÎûòÍ∑∏ Ï§ë ÏïÑÎãàÎçîÎùºÎèÑ ÎßÅÌÅ¨ ÎØ∏Î¶¨Î≥¥Í∏∞ ÏúÑÌï¥ Î¶¨ÌîÑÎ†àÏãú
    if (state.tool === "link") redrawOverlay();
  }

  // Î°±ÌîÑÎ†àÏä§ Ï§ëÏù¥Î©¥ ÏïàÎÇ¥ÏÑ†Îßå Î≥¥Ïó¨Ï§ÄÎã§ (Ïä§ÎÉÖÏùÄ ÌïòÏßÄ ÏïäÏùå)
  if (state.longPress.active && state.longPress.anchor) {
    const dx = Math.abs(state.mouse.x - state.longPress.anchor.x);
    const dy = Math.abs(state.mouse.y - state.longPress.anchor.y);
    const orient = dx >= dy ? "h" : "v";
    state.snapGuide = { anchor: state.longPress.anchor, orient };
  }
});

let lpStartClient = null;

els.overlay.addEventListener(
  "pointerdown",
  (ev) => {
    if (state.tool !== "node") return;
    if (ev.button !== 0) return;
    if (ev.target !== els.overlay) return;

    const { x: px, y: py, rect } = imagePointFromClient(ev);
    if (px < 0 || py < 0 || px > rect.width || py > rect.height) return;

    let x = px,
      y = py;
    const { v, h } = state.snap.cand || {};

    // 1) v/h Îëò Îã§ ÏûàÏúºÎ©¥ ÍµêÏ∞®Ï†êÏúºÎ°ú
    if (v && h) {
      x = v.x;
      y = h.y;
    }
    // 2) ÌïòÎÇòÎßå ÏûàÏúºÎ©¥ Í∑∏ Ï∂ïÏúºÎ°ú
    else if (v) {
      x = v.x;
    } else if (h) {
      y = h.y;
    }

    // 3) (ÏòµÏÖò) Shift: ÏßÅÏ†Ñ ÎÖ∏Îìú Í∏∞Ï§Ä ÏßÅÍµê Ïä§ÎÉÖ Ïö∞ÏÑ†
    if (state.keys.shift && state.graph.nodes.length) {
      const last = state.graph.nodes[state.graph.nodes.length - 1];
      const dx = Math.abs(x - last.x),
        dy = Math.abs(y - last.y);
      if (dx >= dy) y = last.y;
      else x = last.x;
    }

    const newNode = {
      id: `n_${Math.random().toString(36).slice(2, 8)}`,
      name: "",
      x,
      y,
    };
    state.graph.nodes.push(newNode);
    selectNode(newNode.id);
    redrawOverlay();

    ev.preventDefault();
    ev.stopPropagation();
  },
  { passive: false }
);

// els.overlay.addEventListener("pointerdown", (e) => {
//   const pt = imagePointFromClient(e); // Ïù¥ÎØ∏ÏßÄ Ï¢åÌëúÎ°ú Î≥ÄÌôòÌïòÎäî Í∏∞Ï°¥ Ìï®Ïàò
//   // Í∏∞Ï§Ä ÏïµÏª§: ÎìúÎûòÍ∑∏ Ï§ëÏù¥Î©¥ Í∑∏ ÎÖ∏Îìú ÏãúÏûëÏ†ê, ÎßÅÌÅ¨ ÎèÑÍµ¨Î©¥ Ï≤´ ÎÖ∏Îìú, ÏïÑÎãàÎ©¥ ÌòÑÏû¨ Ìè¨Ïù∏Ìä∏
//   let anchor = pt;
//   if (
//     typeof draggingNodeId === "string" ||
//     typeof draggingNodeId === "number"
//   ) {
//     anchor = { x: nodeStart?.x ?? pt.x, y: nodeStart?.y ?? pt.y };
//   } else if (state.tool === "link" && pendingLinkFrom != null) {
//     const n0 = state.graph.nodes.find((n) => n.id === pendingLinkFrom);
//     if (n0) anchor = { x: n0.x, y: n0.y };
//   }

//   clearTimeout(state.longPress.timer);
//   state.longPress.active = false;
//   state.longPress.anchor = anchor;
//   lpStartClient = { x: e.clientX, y: e.clientY };

//   state.longPress.timer = setTimeout(() => {
//     state.longPress.active = true; // Î°±ÌîÑÎ†àÏä§ ÏßÑÏûÖ
//     state.snapGuide = { anchor, orient: "h" }; // Ï¥àÍ∏∞Í∞í
//     redrawOverlay();
//   }, state.longPress.threshold);
// });

els.overlay.addEventListener("pointerup", (ev) => {
  if (draggingNodeId) {
    draggingNodeId = null;
    dragStart = null;
    nodeStart = null;
    state.snapGuide = null;
    try {
      els.overlay.releasePointerCapture(ev.pointerId);
    } catch {}
  }
});

let lastNodeDownTs = 0;
let suppressNextClick = false;

els.overlay.addEventListener(
  "pointerdown",
  (ev) => {
    if (state.tool !== "node") return;
    if (ev.button !== 0) return;
    if (ev.target !== els.overlay) return;

    const now = performance.now();
    if (now - lastNodeDownTs < 200) return; // ÎîîÎ∞îÏö¥Ïä§
    lastNodeDownTs = now;

    const { x: px, y: py, rect } = imagePointFromClient(ev);
    if (px < 0 || py < 0 || px > rect.width || py > rect.height) return;

    let x = px,
      y = py;
    const { v, h } = state.snap?.cand || {};

    // v/h Îëò Îã§ ‚Üí ÍµêÏ∞®Ï†ê, ÌïòÎÇòÎßå ‚Üí Í∑∏ Ï∂ïÏúºÎ°ú Ïä§ÎÉÖ
    if (v && h) {
      x = v.x;
      y = h.y;
    } else if (v) {
      x = v.x;
    } else if (h) {
      y = h.y;
    }

    // (ÏòµÏÖò) Shift ÏßÅÍµê Ïä§ÎÉÖ Ïö∞ÏÑ†ÌïòÎ†§Î©¥ Ïù¥ Î∏îÎ°ùÏùÑ ÏúÑÎ°ú Ïò¨Î†§
    if (state.keys.shift && state.graph.nodes.length) {
      const last = state.graph.nodes[state.graph.nodes.length - 1];
      const dx = Math.abs(x - last.x),
        dy = Math.abs(y - last.y);
      if (dx >= dy) y = last.y;
      else x = last.x;
    }

    const newNode = {
      id: `n_${Math.random().toString(36).slice(2, 8)}`,
      name: "",
      x,
      y,
    };
    state.graph.nodes.push(newNode);
    selectNode(newNode.id);
    redrawOverlay();

    // üëâ Îí§Îî∞Î•¥Îäî clickÏùÑ Ìïú Î≤à Î¨¥Ïãú
    suppressNextClick = true;
    ev.preventDefault();
    ev.stopPropagation();
  },
  { passive: false }
);

function cancelLongPress() {
  clearTimeout(state.longPress.timer);
  state.longPress.timer = null;
  state.longPress.active = false;
}

function endLongPress() {
  cancelLongPress();
  state.snapGuide = null;
  redrawOverlay();
}

function endLongPressDeferred(e) {
  // Î°±ÌîÑÎ†àÏä§ ÏÉÅÌÉúÍ∞Ä ÏïÑÎãàÎ©¥ Î¨¥Ïãú
  if (!state.longPress?.timer && !state.longPress?.active) return;

  // ÎßÅÌÅ¨ ÎèÑÍµ¨Ïùº ÎïåÎäî ÌÅ¥Î¶≠ Ï≤òÎ¶¨(ÎÖ∏Îìú ÏÑ†ÌÉù/Ïó∞Í≤∞)Í∞Ä Î®ºÏ†Ä ÎÅùÎÇú Îí§Ïóê Ï¢ÖÎ£å
  if (state.tool === "link") {
    setTimeout(() => {
      cancelLongPress(); // ÌÉÄÏù¥Î®∏ ÌÅ¥Î¶¨Ïñ¥ + active=false
      state.snapGuide = null; // Í∞ÄÏù¥Îìú Ï†úÍ±∞
      redrawOverlay(); // ÌôîÎ©¥ Í∞±Ïã† (ÌÅ¥Î¶≠ ÌõÑÏóê)
    }, 0); // ‚Üê ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏Î≥¥Îã§ ÎÇòÏ§ëÏóê Ïã§Ìñâ
    return;
  }

  // ÎÇòÎ®∏ÏßÄ ÎèÑÍµ¨Îäî Ï¶âÏãú Ï¢ÖÎ£åÌï¥ÎèÑ OK
  cancelLongPress();
  state.snapGuide = null;
  redrawOverlay();
}
els.overlay.addEventListener("pointerup", endLongPressDeferred, {
  passive: true,
});
els.overlay.addEventListener("pointercancel", endLongPressDeferred, {
  passive: true,
});
els.overlay.addEventListener("pointerleave", endLongPressDeferred, {
  passive: true,
});

els.overlay.addEventListener("pointermove", (e) => {
  // Ïù¥ÎèôÏù¥ ÏûÑÍ≥ÑÍ∞íÏùÑ ÎÑòÏúºÎ©¥ Î°±ÌîÑÎ†àÏä§ Ï∑®ÏÜå(Ïã§Ïàò Î∞©ÏßÄ)
  if (state.longPress.timer && lpStartClient) {
    const dx = Math.abs(e.clientX - lpStartClient.x);
    const dy = Math.abs(e.clientY - lpStartClient.y);
    if (dx > state.longPressMoveCancel || dy > state.longPressMoveCancel) {
      cancelLongPress();
    }
  }

  // Î°±ÌîÑÎ†àÏä§ ÏÉÅÌÉúÎ©¥ Í∞ÄÏù¥ÎìúÎßå Í∞±Ïã†(Ïä§ÎÉÖÏùÄ X)
  if (state.longPress.active && state.longPress.anchor) {
    const pt = imagePointFromClient(e);
    const dx = Math.abs(pt.x - state.longPress.anchor.x);
    const dy = Math.abs(pt.y - state.longPress.anchor.y);
    const orient = dx >= dy ? "h" : "v";
    state.snapGuide = { anchor: state.longPress.anchor, orient };
    redrawOverlay();
  }
});

// Î∞∞Í≤Ω Ïù¥ÎØ∏ÏßÄ ÏúÑ ÌÅ¥Î¶≠ÏúºÎ°úÎßå Ìé∏Ïßë (Ïù¥ÎØ∏ÏßÄ ÏóÜÏúºÎ©¥ Î¨¥Ïãú)
els.overlay.addEventListener("click", (ev) => {
  const { x, y, rect } = imagePointFromClient(ev);
  // Ïù¥ÎØ∏ÏßÄ ÏòÅÏó≠ Î∞ñ ÌÅ¥Î¶≠ Î¨¥Ïãú
  if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;

  // if (state.tool === "node") {
  //   if (state.keys.shift && state.graph.nodes.length) {
  //     const last = state.graph.nodes[state.graph.nodes.length - 1];
  //     const dx = Math.abs(x - last.x);
  //     const dy = Math.abs(y - last.y);
  //     if (dx >= dy) y = last.y;
  //     else x = last.x; // ÏàòÌèâ/ÏàòÏßÅ Ïä§ÎÉÖ
  //   }
  //   // ({ x, y } = snapToAxisOfExisting(x, y, 8));
  //   const newNode = {
  //     id: `n_${Math.random().toString(36).slice(2, 8)}`,
  //     name: "",
  //     x,
  //     y,
  //   };
  //   state.graph.nodes.push(newNode);
  //   selectNode(newNode.id);
  //   redrawOverlay();
  // } else
  if (suppressNextClick) {
    suppressNextClick = false;
    ev.preventDefault();
    ev.stopPropagation();
    return;
  }
  if (state.tool === "select" && ev.target === els.overlay) {
    clearSelection();
  }
});

// Node edits
els.nodeName.addEventListener("input", () => {
  if (state.selection.type !== "node") return;
  const n = state.graph.nodes.find((x) => x.id === state.selection.id);
  if (!n) return;
  n.name = els.nodeName.value;
  redrawOverlay();
});
els.nodeX.addEventListener("input", () => {
  if (state.selection.type !== "node") return;
  const n = state.graph.nodes.find((x) => x.id === state.selection.id);
  const v = Number(els.nodeX.value);
  if (!Number.isFinite(v)) return;
  n.x = v;
  redrawOverlay();
});
els.nodeY.addEventListener("input", () => {
  if (state.selection.type !== "node") return;
  const n = state.graph.nodes.find((x) => x.id === state.selection.id);
  const v = Number(els.nodeY.value);
  if (!Number.isFinite(v)) return;
  n.y = v;
  redrawOverlay();
});

// Link edits
els.linkFrom.addEventListener("change", () => {
  if (state.selection.type !== "link") return;
  const l = state.graph.links.find((x) => x.id === state.selection.id);
  l.a = els.linkFrom.value;
  redrawOverlay();
});
els.linkTo.addEventListener("change", () => {
  if (state.selection.type !== "link") return;
  const l = state.graph.links.find((x) => x.id === state.selection.id);
  l.b = els.linkTo.value;
  redrawOverlay();
});
els.linkType.addEventListener("change", () => {
  if (state.selection.type !== "link") return;
  const l = state.graph.links.find((x) => x.id === state.selection.id);
  l.type = els.linkType.value;
});

function applyToolCursor() {
  const cur =
    state.tool === "node" || state.tool === "link" ? "crosshair" : "default";
  if (els && els.overlay) els.overlay.style.cursor = cur;
}

function setTool(next) {
  state.tool = next;
  if (els && els.status) els.status.textContent = `ÌòÑÏû¨ ÎèÑÍµ¨: ${state.tool}`;

  // Î≤ÑÌäº ÌôúÏÑ±Ìôî ÌÜ†Í∏Ä
  document.querySelectorAll(".toolbtn[data-tool]").forEach((btn) => {
    const isActive = btn.getAttribute("data-tool") === next;
    btn.classList.toggle("active", isActive);
    btn.setAttribute("aria-pressed", isActive ? "true" : "false");
  });

  if (state.tool !== "link") {
    pendingLinkFrom = null;
  }

  // Ïó¨Í∏∞ Îëê Ï§ÑÏù¥ Îß® ÎÅùÏóê Ïò§ÎèÑÎ°ù
  applyToolCursor();
  redrawOverlay();
}

// Î≤ÑÌäº Î∞îÏù∏Îî©ÏùÄ DOMÏù¥ Ï§ÄÎπÑÎêú ÌõÑÏóê
document.querySelectorAll(".toolbtn[data-tool]").forEach((btn) => {
  btn.addEventListener("click", () => {
    setTool(btn.getAttribute("data-tool"));
  });
});

setTool("select");
